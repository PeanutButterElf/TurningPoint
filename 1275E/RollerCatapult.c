#pragma config(Sensor, in1,    fieldPos,       sensorPotentiometer)
#pragma config(Sensor, in2,    side,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  catapult,       sensorQuadEncoder)
#pragma config(Sensor, dgtl12, cTouch,         sensorTouch)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port4,           leftCatapult,  tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port6,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           backRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port8,           rightCatapult, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rollers,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          flipper,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int d8Flag = 0;
int rollerSpeed = 0;
int toggleStateRoller = 0;
int encoderGoal = 107; // Higher for lower catapult
int additionBonus = 5;
int idlePower = 10;

void autoShootFunction() {
	resetMotorEncoder(leftCatapult);
	if(SensorValue[cTouch] != 1) {
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 1);
		motor[leftCatapult] = motor[rightCatapult] = 0;
		wait1Msec(200);
		resetMotorEncoder(leftCatapult);
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 0 && getMotorEncoder(leftCatapult) >= (encoderGoal + additionBonus));
		motor[leftCatapult] = motor[rightCatapult] = idlePower;
	} else {
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 0 && getMotorEncoder(leftCatapult) >= encoderGoal);
		motor[leftCatapult] = motor[rightCatapult] = idlePower;
	}

}

task autoShoot() {
	resetMotorEncoder(leftCatapult);
	if(SensorValue[cTouch] != 1) {
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 1);
		motor[leftCatapult] = motor[rightCatapult] = 0;
		wait1Msec(200);
		resetMotorEncoder(leftCatapult);
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 0 && getMotorEncoder(leftCatapult) >= (encoderGoal + additionBonus));
		motor[leftCatapult] = motor[rightCatapult] = idlePower;
	} else {
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[cTouch] == 0 && getMotorEncoder(leftCatapult) >= encoderGoal);
		motor[leftCatapult] = motor[rightCatapult] = idlePower;
	}

}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/



void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void driveAndScoreCap() {
	int rotationCount = 950;
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = -127;
	motor[rollers] = 127;
	//waitUntil(getMotorEncoder(backLeft) >= rotationCount || getMotorEncoder(backRight) >= rotationCount);
	wait1Msec(1200);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;
	wait1Msec(100);
	//motor[rollers] = 0;
}
/*
void Turn(int direction, int amount) {
		resetMotorEncoder(backLeft);
		resetMotorEncoder(backRight);
		motor[frontLeft] = motor[backLeft] = (-127 * direction);
		motor[frontRight] = motor[backRight] = (127 * direction);
		if (direction == 1) {
		waitUntil(getMotorEncoder(backLeft) >= amount || getMotorEncoder(backRight) <= (amount * -1));
		}
		else {
			waitUntil((getMotorEncoder(backLeft) <= (amount * -1)) || getMotorEncoder(backRight) >= amount);
		}
		motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;
}
*/

void Drive(int rotations) {
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 127;
	//waitUntil(getMotorEncoder(backLeft) >= rotations || getMotorEncoder(backRight) >= rotations);
	wait1Msec(rotations);
	//motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;

}

void DriveBack(int rotations) {
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = -127;
	//waitUntil(getMotorEncoder(backLeft) <= (rotations * -1) || getMotorEncoder(backRight) <= (rotations * -1));
	wait1Msec(rotations);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;
}

void turnL(int rotations) {
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	motor[frontLeft] = motor[backLeft] = -127;
	motor[frontRight] = motor[backRight] = 127;
	//waitUntil(getMotorEncoder(backLeft) <= (-1 * rotations) || getMotorEncoder(backRight) >= rotations);
	wait1Msec(rotations);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;
}

void turnR(int rotations) {
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	motor[frontLeft] = motor[backLeft] = 127;
	motor[frontRight] = motor[backRight] = -127;
	//waitUntil(getMotorEncoder(backLeft) >= rotations || getMotorEncoder(backRight) <= (rotations * -1));
	wait1Msec(rotations);
	motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;
}

task autonomous() {
	if (SensorValue[fieldPos] > 2000) {
		// Drive, Shoot, Get Low Flag, and then Return
		Drive(50);
		wait1Msec(50);
		autoShootFunction();
		if (SensorValue[side] > 2000) turnR(300);
		else turnL(300);
		wait1Msec(50);
		Drive(100);
		DriveBack(600);
	} else {
		// Drive and Score Cap,
		//driveAndScoreCap();
		//Drive(200);
		/*
		DriveBack(1000);
		if (SensorValue[side] > 2000) turnL(400);
		else turnR(400);
		Drive(500);
		DriveBack(2900);
		*/
		motor[rollers] = -127;
		DriveBack(1900);
		Drive(200);
		motor[frontLeft] = motor[backLeft] = motor[frontRight] = motor[backRight] = 0;

	}
	//Turn(direction, 280);

	//driveAndScoreCap();

	//DriveBack(30);

	//Turn(direction, 90);

	//Drive(250);
}
	//returnBack();


// End of Auton Control ------------------------------------------------------------------------------------------------


/*
	if(SensorValue[fieldPos] > 2000 && SensorValue[side] < 2000) {
		// Away from Flag on Blue
	}
	else if (SensorValue[fieldPos] < 2000 && SensorValue[side] < 2000) {
		// Close to Flag on Blue
	}
	else if (SensorValue[fieldPos] > 2000 && SensorValue[side] > 2000) {
		// Away from Flag on Red
	}
	else if (SensorValue[fieldPos] < 2000 && SensorValue[side] > 2000) {
		// Close from Flag on Red
	}
*/


// User Control ---------------------------------------------------------------------------------

task usercontrol() {
	// User control code here, inside the loop

	while (1) {
		// Tank Drive / Dank Drive
		motor[frontLeft] = motor[backLeft] = vexRT[Ch3];
		motor[frontRight] = motor[backRight] = vexRT[Ch2];
		// --------------------------------------------------

		// Control Rollers
		// 8D for ON or OFF, 8L for reverse ON or OFF.
		if (vexRT[Btn8D] && !d8Flag) {
			rollerSpeed = (toggleStateRoller ? 127 : 0);
			toggleStateRoller = (toggleStateRoller ? 0 : 1);
		}

		if (vexRT[Btn8L] && !d8Flag) {
			rollerSpeed = (toggleStateRoller ? -127 : 0);
			toggleStateRoller = (toggleStateRoller ? 0 : 1);
		}

		if (vexRT[Btn8D] > 0) d8Flag = vexRT[Btn8D];
		else d8Flag = vexRT[Btn8L];
		motor[rollers] = rollerSpeed;
		// --------------------------------------------------

		// Catapult
		// 6O Shoot and pull back to correct value.
		if (vexRT[Btn6D]) {// && !d6Flag) {
			startTask(autoShoot);
		}

		if (vexRT[Btn5U]) {
			motor[flipper] = 127;
		} else if(vexRT[Btn5D]) {
			motor[flipper] = -127;
		} else {
			motor[flipper] = 0;
		}

		//d6Flag = vexRT[Btn6D];
	}
}
		// --------------------------------------------------
