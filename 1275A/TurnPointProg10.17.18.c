#pragma config(Sensor, in1,    lift,           sensorPotentiometer)
#pragma config(Sensor, in2,    flip,           sensorPotentiometer)
#pragma config(Sensor, in3,    autonDirection, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl10, jump,           sensorNone)
#pragma config(Sensor, dgtl11, resetSwitch,    sensorTouch)
#pragma config(Sensor, dgtl12, catapultSwitch, sensorTouch)
#pragma config(Motor,  port1,           ballIntake,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftCatapult,  tmotorVex393_MC29, openLoop, encoderPort, dgtl5)
#pragma config(Motor,  port7,           rightCatapult, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port10,          flipper,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
int rightDriveVal;
int leftDriveVal;
int liftEnable = 1;
int flipperEnable = 1;
int driveEnable = 1;
int catapultEnable = 1;
int autoLiftVal;
bool flipperUp;
int maxLift = 0;
bool flipperUpOk = true;

task autoLift ()
{
	liftEnable = 0;

	while(!liftEnable && SensorValue[lift] > autoLiftVal)
		motor[leftLift] = motor[rightLift] = 127;

	liftEnable = 1;
}

task autoFlip ()
{
	flipperEnable = 0;
	if(flipperUp)
	{
		while(!flipperEnable && SensorValue[flip] > 655)
			motor[flipper] = -127;
	}
	else
	{
		while(!flipperEnable && SensorValue[flip] < 1900 && flipperUpOk)
			motor[flipper] = 127;
	}
	flipperEnable = 1;
}


task autoLaunch()
{
	catapultEnable = 0;
	while(!catapultEnable)
	{
		motor[leftCatapult] = motor[rightCatapult] = 127;
		waitUntil(SensorValue[catapultSwitch] == 1);
		wait1Msec(200);
		waitUntil(SensorValue[catapultSwitch] == 0);
		resetMotorEncoder(leftCatapult);

		//here is the parts that can get changed
		waitUntil(getMotorEncoder(leftCatapult) /*here is the changeable part-->*/ > 100);
		motor[leftCatapult] = motor[rightCatapult] = 0;

		//exits this part (very important)
		catapultEnable = 1;
	}

}
void pre_auton(){}


task displayVal()
{
	while(true)
	{
		long a = getMotorEncoder(leftDrive);
		long b = getMotorEncoder(rightDrive);
		long c = SensorValue[lift];
		writeDebugStream("Left Drive: %d", a);
		writeDebugStreamLine("Right Drive: %d", b);
		writeDebugStreamLine("Lift: %d", c);
		if(SensorValue[resetSwitch])
		{
			resetMotorEncoder(rightDrive);
			resetMotorEncoder(leftDrive);
			resetMotorEncoder(leftCatapult);
		}
		wait1Msec(2);
		clearDebugStream();

	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	resetMotorEncoder(rightDrive);
	resetMotorEncoder(leftDrive);
	motor[flipper] = -127;
	waitUntil(SensorValue[flip] < 655);
	motor[flipper] = 0;
	startTask(autoLaunch);
	if(SensorValue[jump] == 0)
	{
		wait1Msec(1000);
		motor[flipper] = 127;
		waitUntil(SensorValue[flip] > 1600);
		motor[flipper] = 0;
		motor[leftDrive] = 127;
		motor[rightDrive] = 80;
		waitUntil(getMotorEncoder(leftDrive) > 1000);
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[leftDrive] = -127;
		motor[rightDrive] = -70;
		waitUntil(getMotorEncoder(leftDrive) < -1480);
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		int addVal;
		if(SensorValue[autonDirection] < 1850)
		{
			motor[leftDrive] = 127;
			motor[rightDrive] = -80;
			addVal = 63;
			waitUntil(getMotorEncoder(leftDrive) > 240);
		}
		else
		{
			motor[leftDrive] = -127;
			motor[rightDrive] = 80;
			addVal = 5;
			waitUntil(getMotorEncoder(rightDrive) > 180);
		}
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = motor[leftDrive] = 127;

		waitUntil(getMotorEncoder(rightDrive) > 1530 + addVal);
		motor[rightDrive] = motor[leftDrive] = 0;
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		liftEnable = flipperEnable = driveEnable = catapultEnable = 1;
		//250 1000
		/*motor[flipper] = 127;
		waitUntil(SensorValue[flip] < 650);

		motor[flipper] = 0;
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = motor[leftDrive] = 127;
		waitUntil(getMotorEncoder(leftDrive)>600);

		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = -127;
		motor[leftDrive] = 127;
		waitUntil(getMotorEncoder(leftDrive)>350);

		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = motor[leftDrive] = 127;
		waitUntil(getMotorEncoder(rightDrive)>600);

		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = motor[leftDrive] = 0;
		motor[leftLift] = motor[rightLift] = 127;
		waitUntil(SensorValue[lift] < 2500);

		motor[leftLift] = motor[rightLift] = 0;
		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = -127;
		motor[leftDrive] = 127;
		waitUntil(getMotorEncoder(leftDrive)>350);

		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[rightDrive] = motor[leftDrive] = 127;
		waitUntil(getMotorEncoder(leftDrive)>1000);

		resetMotorEncoder(rightDrive);
		resetMotorEncoder(leftDrive);
		motor[leftDrive] = motor[rightDrive] = 0;*/
	}

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/



task usercontrol()
{
	startTask(displayVal);

	// User control code here, inside the loop
	int buttonPressed;
	int buttonToggleState;
	int liftPressed;
	int liftToggleState;

	flipperEnable = driveEnable = liftEnable = 1;

	int D8pressed = 50; //50 is just a random number that is not 1 or 0
	int R8pressed = 50;
	int L8pressed = 50;
	int R7pressed = 50;
	int intakeVal;
	while (true)
	{
		//TOGGLE CONTROLS

		if (vexRT[Btn8U])
		{
			if (!buttonPressed)
			{
				// change the toggle state
				buttonToggleState = 1 - buttonToggleState;

				// Note the button is pressed
				buttonPressed = 1;

			}
		}
		else
		{
			// the button is not pressed
			buttonPressed = 0;
		}


		// Now do something with our toggle flag
		if (buttonToggleState)
			intakeVal = 127;
		else
			intakeVal = 0;

		if(vexRT[Btn7U])
		{
			intakeVal = -127;
		}
		motor[ballIntake] = intakeVal;


		if (vexRT[Btn7D])
		{
			if (!liftPressed)
			{
				// change the toggle state
				liftToggleState = 1 - liftToggleState;

				// Note the button is pressed
				liftPressed = 1;

			}
		}
		else
		{
			// the button is not pressed
			liftPressed = 0;
		}

		if (liftToggleState)
			maxLift = 2300;
		else
			maxLift = 0;

		//if low heigh toggle is on, flipper is disabled at a certain height
		if(SensorValue[lift] < 2580 && maxLift == 2300)
			flipperUpOk = false;
		else
			flipperUpOk = true;
		//MANUAL CONTROL
		leftDriveVal  = vexRT[Ch3] + vexRT[Ch4];
		rightDriveVal = vexRT[Ch3] - vexRT[Ch4];


		motor[rightDrive] = rightDriveVal;
		motor[leftDrive] = leftDriveVal;
		if(liftEnable && SensorValue[lift] > maxLift)
			motor[rightLift] = motor[leftLift] = vexRT[Ch2];

		//Corrects if too high
		if(SensorValue[lift] < maxLift)
		{
			liftEnable = 1;
			motor[rightLift] = motor[leftLift] = -30;
		}

		if(catapultEnable)
			motor[rightCatapult] = motor[leftCatapult] = vexRT[Btn6D] * 127;

		if(flipperEnable)
		{
			//motor[flipper] = (vexRT[Btn5U]-vexRT[Btn5D]) * 127;
			if(vexRT[Btn5U] && flipperUpOk)
				motor[flipper] = 127;
			else if(vexRT[Btn5D])
				motor[flipper] = -127;
			else
				motor[flipper] = 0;
		}


		//Motor Enable Override
		if(vexRT[Btn7L])
			liftEnable = flipperEnable = driveEnable = catapultEnable = 1;

		//is the flipper up or down?
		if(SensorValue[flip] > 1325)
			flipperUp = true;
		else
			flipperUp = false;

		//Automation Summons
		//High Lift: 1250
		//Low Lift:  1760
		//low flip:  655
		//mid flip:  1325
		//high flip: 1980

		//summons automatic task if button is currently pressed but was not pressed last loop
		if(vexRT[Btn8D] && !D8pressed && liftEnable && SensorValue[lift] > maxLift)
		{
			autoLiftVal = 1760;
			startTask(autoLift);
		}

		if(vexRT[Btn8R] && !R8pressed && liftEnable && SensorValue[lift] > maxLift)
		{
			autoLiftVal = 1250;
			startTask(autoLift);
		}

		if(vexRT[Btn8L] && !L8pressed && flipperEnable)
			startTask(autoFlip);

		if(vexRT[Btn7R] && !R7pressed && catapultEnable)
			startTask(autoLaunch);

		D8pressed = vexRT[Btn8D];
		R8pressed = vexRT[Btn8R];
		L8pressed = vexRT[Btn8L];
		R7pressed = vexRT[Btn7R];
	}

}
